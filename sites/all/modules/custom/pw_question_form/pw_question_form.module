<?php

/**
 * @file pw_question_form.module
 * helper functions for question form.
 */


/**
 * Implements hook_form_alter()..
 */
function pw_question_form_form_alter(&$form, &$form_state, $form_id) {

  if ($form_id == 'webform_client_form_10446') {

    // add custom validations
    $form['#validate'][] = 'pw_question_form_form_validate';

    // load recipient user by path
    if(empty($form['submitted']['recipient']['#value'])){
      $user = _pw_get_current_user();
    }
    // load recipient user by parameter
    else{
      $user_name = $form['submitted']['recipient']['#value'];
      $user = user_load_by_name($user_name);
    }

    // exit if user was not found
    if(empty($user) || $user === FALSE){
      return;
    }

    // need username for redirection after submit
    $form['submitted']['recipient']['#value'] = $user->name;

    // load full parliament term
    $parliament = taxonomy_term_load($user->field_user_parliament[LANGUAGE_NONE][0]['tid']);

    // election date
    $date_election = $parliament->field_parliament_election[LANGUAGE_NONE][0]['value'];

    // check parliament is within valid dates
    $parliament_is_valid = _check_parliament_active($parliament);

    $body_markup = '';

    // check if candidate and election date was reached
    if(_pw_user_has_role($user, 'Candidate') && !empty($date_election)){

      // day before election - close question form
      $day_before_election = strtotime($date_election) - 6*60*60;
      if(time() > $day_before_election && $user->name != 'jakob-maria-mierscheid'){
        $body_markup = '<div class="pw-messages warning">Die Fragefunktion in diesem Profil wurde einen Tag vor der Wahl, am :day_before_election, geschlossen.</div>';
        $body_markup = str_replace(':day_before_election', date('d.m.Y H:i', $day_before_election), $body_markup);
      }
    }

    // check valid dates if there was no message set before
    if(!$parliament_is_valid && empty($body_markup)){
      $parliament_end_date = '';
      foreach($parliament->field_parliament_valid[LANGUAGE_NONE] as $date_parliament_valid){

        // found start date
        if(strtotime($date_parliament_valid['value']) > time()){
          $parliament_date_start = $date_parliament_valid['value'];
        }

        // save latest end date
        elseif($date_parliament_valid['value2'] > $parliament_end_date){
          $parliament_end_date = $date_parliament_valid['value2'];
        }
      }

      // start date was found - announce start date but keep form closed
      if(isset($parliament_date_start)){
        $body_markup = '<div class="pw-messages warning">Die Fragefunktion in diesem Profil wird ab dem :date_start frei geschaltet sein. Bitte gedulden Sie sich so lange.</div>';
        $body_markup = str_replace(':date_start', date('d.m.Y H:i', strtotime($parliament_date_start)), $body_markup);
      }

      // no start date was found - publish last end date
      elseif(!empty($parliament_end_date)){
        $body_markup = '<div class="pw-messages warning">Die Fragefunktion ist diesem Profil wurde am :date_end geschlossen.</div>';
        $body_markup = str_replace(':date_end', date('d.m.Y H:i', strtotime($parliament_end_date)), $body_markup);
      }
      // no dates were found - publish general message
      else{
        $body_markup = '<div class="pw-messages warning">Die Fragefunktion ist diesem Profil wurde geschlossen.</div>';
      }
    }

    // show message
    $form['#node']->content['body'][0]['#markup'] = $body_markup;

    // if there is a message - keep question form closed
    if(!empty($body_markup)){
      unset($form['#node']->content['field_webform_footer']);
      unset($form['submitted']);
      unset($form['actions']);
      return;
    }

    // set uuid as recipient external id
    $form['submitted']['recipient_external_id']['#value'] = $user->uuid;

    // set recipient parliament
    $form['submitted']['recipient_parliament']['#value'] = $parliament->name;

    // query for subject terms tagged with same parliament as user has
    $query = new EntityFieldQuery();
    $query->entityCondition('entity_type', 'taxonomy_term')
          ->entityCondition('bundle', 'dialogue_topics')
          ->fieldCondition('field_parliament', 'tid', $parliament->tid)
          ->propertyOrderBy('name');
    $result = $query->execute();
    $subject_terms = taxonomy_term_load_multiple(array_keys($result['taxonomy_term']), 'dialogue_topics');

    // add subject to form element
    $a_options = array();
    foreach($subject_terms as $subject_key => $subject_term){
      $a_options[$subject_term->name] = $subject_term->name;
    }
    $form['submitted']['subject']['#options'] = $a_options;
  }
}

/**
 * Implements hook_form_validate()..
 * custom validations on webform submission
 */
function pw_question_form_form_validate($form_id, $form_values){

  // check if question has less than 2000 chars
  if(strlen($form_values['values']['submitted']['question']) > 2000){
    form_set_error('question', 'Ihre Frage hat mehr als die zulässigen 2000 Zeichen.');
  }

  // check user exists
  $user_name = $form_values['values']['submitted']['recipient'];
  $user = user_load_by_name($user_name);
  if($user === FALSE){
    form_set_error('user', 'Empfänger existiert nicht.');
  }
}
